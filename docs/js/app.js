/**
 * PSD2 API Discovery - Frontend Application
 *
 * This version loads pre-scraped data from JSON files generated by GitHub Actions.
 */

// Global state
let scanResults = null;
let allApis = [];
let scanLogs = [];

// Data URLs
const DATA_URL = 'data/apis.json';
const LOG_URL = 'data/scan-log.json';

/**
 * Initialize the application
 */
document.addEventListener('DOMContentLoaded', () => {
    loadData();
});

/**
 * Load API data from JSON file
 */
async function loadData() {
    showLoading();

    try {
        // Load API data
        const response = await fetch(DATA_URL + '?t=' + Date.now()); // Cache bust
        if (!response.ok) {
            throw new Error(`Failed to load data: ${response.status}`);
        }

        scanResults = await response.json();
        allApis = scanResults.apis || [];

        // Load scan logs
        try {
            const logResponse = await fetch(LOG_URL + '?t=' + Date.now());
            if (logResponse.ok) {
                const logData = await logResponse.json();
                scanLogs = logData.logs || [];
            }
        } catch (e) {
            console.warn('Could not load scan logs:', e);
            scanLogs = [];
        }

        // Update last updated time
        updateLastUpdated(scanResults.lastUpdated);

        // Show results or empty state
        if (allApis.length > 0) {
            displayResults();
        } else {
            showEmpty();
        }

    } catch (error) {
        console.error('Error loading data:', error);
        showError(error.message);
    }
}

/**
 * Show loading state
 */
function showLoading() {
    document.getElementById('loading-section').style.display = 'block';
    document.getElementById('results-section').style.display = 'none';
    document.getElementById('empty-section').style.display = 'none';
    document.getElementById('error-section').style.display = 'none';
}

/**
 * Show empty state
 */
function showEmpty() {
    document.getElementById('loading-section').style.display = 'none';
    document.getElementById('results-section').style.display = 'none';
    document.getElementById('empty-section').style.display = 'block';
    document.getElementById('error-section').style.display = 'none';
}

/**
 * Show error state
 */
function showError(message) {
    document.getElementById('loading-section').style.display = 'none';
    document.getElementById('results-section').style.display = 'none';
    document.getElementById('empty-section').style.display = 'none';
    document.getElementById('error-section').style.display = 'block';
    document.getElementById('error-message').textContent = message;
}

/**
 * Update last updated timestamp
 */
function updateLastUpdated(timestamp) {
    const element = document.getElementById('last-updated-time');
    if (!timestamp) {
        element.textContent = 'Never';
        return;
    }

    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    let relativeTime;
    if (diffMins < 1) {
        relativeTime = 'just now';
    } else if (diffMins < 60) {
        relativeTime = `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
    } else if (diffHours < 24) {
        relativeTime = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    } else {
        relativeTime = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    }

    element.textContent = `${date.toLocaleString()} (${relativeTime})`;
}

/**
 * Display scan results
 */
function displayResults() {
    document.getElementById('loading-section').style.display = 'none';
    document.getElementById('results-section').style.display = 'block';
    document.getElementById('empty-section').style.display = 'none';
    document.getElementById('error-section').style.display = 'none';

    // Update stats
    updateStats();

    // Populate table
    populateTable(allApis);

    // Show scan details
    showScanDetails();

    // Show logs
    displayLogsInResults();
}

/**
 * Update statistics cards
 */
function updateStats() {
    document.getElementById('total-apis').textContent = allApis.length;
    document.getElementById('total-sites').textContent = scanResults.scanResults?.length || 0;

    // Calculate total pages scanned
    let totalPages = 0;
    if (scanResults.scanResults) {
        scanResults.scanResults.forEach(result => {
            totalPages += result.pagesScanned || 0;
        });
    }
    document.getElementById('total-pages').textContent = totalPages;

    // Count by API type
    const aisCount = allApis.filter(api => api.api_type === 'AIS').length;
    const pisCount = allApis.filter(api => api.api_type === 'PIS').length;
    const cafCount = allApis.filter(api => api.api_type === 'CAF').length;

    document.getElementById('ais-count').textContent = aisCount;
    document.getElementById('pis-count').textContent = pisCount;
    document.getElementById('caf-count').textContent = cafCount;
}

/**
 * Populate the API table
 */
function populateTable(apis) {
    const tbody = document.getElementById('api-table-body');
    tbody.innerHTML = '';

    if (apis.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    No APIs found matching your criteria.
                </td>
            </tr>
        `;
        return;
    }

    apis.forEach(api => {
        const row = document.createElement('tr');

        // Confidence level class
        let confidenceClass = 'confidence-low';
        if (api.confidence_score >= 0.7) {
            confidenceClass = 'confidence-high';
        } else if (api.confidence_score >= 0.4) {
            confidenceClass = 'confidence-medium';
        }

        // API type class
        const typeClass = api.api_type.toLowerCase();

        row.innerHTML = `
            <td>
                <strong>${escapeHtml(api.name)}</strong>
                <br>
                <small style="color: var(--text-secondary);">${escapeHtml(api.url)}</small>
            </td>
            <td>
                <span class="api-type ${typeClass}">${escapeHtml(api.api_type)}</span>
            </td>
            <td>${escapeHtml(truncate(api.description, 150))}</td>
            <td class="link-cell">
                ${api.documentation_url ? `<a href="${escapeHtml(api.documentation_url)}" target="_blank" rel="noopener">Documentation</a><br>` : ''}
                ${api.swagger_url ? `<a href="${escapeHtml(api.swagger_url)}" target="_blank" rel="noopener">Swagger/OpenAPI</a>` : ''}
                ${!api.documentation_url && !api.swagger_url ? '-' : ''}
            </td>
            <td>
                <div class="confidence-bar">
                    <div class="confidence-fill ${confidenceClass}" style="width: ${api.confidence_score * 100}%"></div>
                </div>
                <small>${Math.round(api.confidence_score * 100)}%</small>
            </td>
            <td class="link-cell">
                <a href="${escapeHtml(api.source_page)}" target="_blank" rel="noopener">View Source</a>
            </td>
        `;

        tbody.appendChild(row);
    });
}

/**
 * Show scan details
 */
function showScanDetails() {
    const container = document.getElementById('scan-details-content');
    container.innerHTML = '';

    if (!scanResults.scanResults || scanResults.scanResults.length === 0) {
        container.innerHTML = '<p style="color: var(--text-secondary);">No scan details available.</p>';
        return;
    }

    scanResults.scanResults.forEach(result => {
        const div = document.createElement('div');
        div.className = 'scan-detail-item';

        const statusClass = result.status === 'success' ? 'status-success' : 'status-error';
        const statusText = result.status === 'success' ? 'Completed' : 'Failed';

        div.innerHTML = `
            <h4>${escapeHtml(result.url)}</h4>
            <p>
                Status: <span class="${statusClass}">${statusText}</span>
                ${result.pagesScanned ? ` | Pages Scanned: ${result.pagesScanned}` : ''}
                ${result.apiRelatedPages ? ` | API-Related Pages: ${result.apiRelatedPages.length}` : ''}
                ${result.apis ? ` | APIs Found: ${result.apis.length}` : ''}
            </p>
            ${result.error ? `<p style="color: var(--error-color);">Error: ${escapeHtml(result.error)}</p>` : ''}
        `;

        container.appendChild(div);
    });
}

/**
 * Display logs in the results section
 */
function displayLogsInResults() {
    const logsContent = document.getElementById('scan-logs-content');
    if (!logsContent) return;

    logsContent.innerHTML = '';

    if (scanLogs.length === 0) {
        logsContent.innerHTML = '<div class="log-entry log-info">No logs available.</div>';
        return;
    }

    scanLogs.forEach(log => {
        const entry = document.createElement('div');
        entry.className = `log-entry log-${log.type}`;

        const timestamp = log.timestamp ? new Date(log.timestamp).toLocaleTimeString() : '';
        entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${escapeHtml(log.message)}`;
        logsContent.appendChild(entry);
    });
}

/**
 * Toggle logs visibility
 */
function toggleLogs() {
    const logsContent = document.getElementById('scan-logs-content');
    const toggleBtn = document.getElementById('toggle-logs-btn');

    if (logsContent.classList.contains('collapsed')) {
        logsContent.classList.remove('collapsed');
        toggleBtn.textContent = 'Hide Logs';
    } else {
        logsContent.classList.add('collapsed');
        toggleBtn.textContent = 'Show Logs';
    }
}

/**
 * Filter results based on search and type
 */
function filterResults() {
    const searchTerm = document.getElementById('search-filter').value.toLowerCase();
    const typeFilter = document.getElementById('type-filter').value;

    const filtered = allApis.filter(api => {
        const matchesSearch = !searchTerm ||
            api.name.toLowerCase().includes(searchTerm) ||
            api.description.toLowerCase().includes(searchTerm) ||
            api.url.toLowerCase().includes(searchTerm);

        const matchesType = !typeFilter || api.api_type === typeFilter;

        return matchesSearch && matchesType;
    });

    populateTable(filtered);
}

/**
 * Export results as JSON
 */
function exportJSON() {
    if (!allApis || allApis.length === 0) {
        alert('No APIs to export.');
        return;
    }

    const dataStr = JSON.stringify(allApis, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    downloadBlob(blob, 'api_inventory.json');
}

/**
 * Export results as CSV
 */
function exportCSV() {
    if (!allApis || allApis.length === 0) {
        alert('No APIs to export.');
        return;
    }

    const headers = [
        'name', 'api_type', 'url', 'source_page', 'description',
        'documentation_url', 'swagger_url', 'confidence_score',
        'discovered_at', 'keywords_found'
    ];

    const csvRows = [headers.join(',')];

    for (const api of allApis) {
        const row = headers.map(header => {
            let value = api[header];
            if (Array.isArray(value)) {
                value = value.join('; ');
            }
            // Escape quotes and wrap in quotes
            value = String(value || '').replace(/"/g, '""');
            return `"${value}"`;
        });
        csvRows.push(row.join(','));
    }

    const csvString = csvRows.join('\n');
    const blob = new Blob([csvString], { type: 'text/csv' });
    downloadBlob(blob, 'api_inventory.csv');
}

/**
 * Download a blob as a file
 */
function downloadBlob(blob, filename) {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    a.remove();
}

/**
 * Escape HTML to prevent XSS
 */
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * Truncate text
 */
function truncate(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
}
